# [9.4. いろいろな注意点](https://docs.python.jp/3/tutorial/classes.html#random-remarks)

< [9. クラス](https://docs.python.jp/3/tutorial/classes.html#classes) < [Python チュートリアル](https://docs.python.jp/3/tutorial/index.html) < [ドキュメント](https://docs.python.jp/3/index.html)

## 名前の重複

> データ属性は同じ名前のメソッド属性を上書きしてしまいます。

> 大規模なプログラムでみつけにくいバグを引き起こすことがあるこの偶然的な名前の衝突を避けるには、衝突の可能性を最小限にするような規約を使うのが賢明です。可能な規約としては、メソッド名を大文字で始める、データ属性名の先頭に短い一意な文字列 (あるいはただの下線) をつける、またメソッドには動詞、データ属性には名詞を用いる、などがあります。

規約でなく言語仕様でエラーにしてくれないとバグる。人間の目を頼りにしても解決しない。「人間は必ず間違いを犯す」というのが真理だから。Pythonではエラー検出できないというのなら、「Python言語は大規模になるほどバグを作りこむ可能性が増す」ということである。

これは「注意」して解決する問題ではない。人間の注意で解決するなら、あらゆる問題が解決するはずである。

## protectedアクセス修飾子がない

> データ属性は、メソッドから参照できると同時に、通常のオブジェクトのユーザ (“クライアント”) からも参照できます。言い換えると、クラスは純粋な抽象データ型として使うことができません。

意味不明。「通常のオブジェクトのユーザ (“クライアント”) 」とは一体何を指しているのか。`self`のことか？言い換えも意味不明。「クラスは純粋な抽象データ型として使うことができません」というが、「抽象データ型」とやらの説明もしないまま、さらに「純粋な」と形容されている。何を言っているのかわからない。

もしかして「アクセス修飾子`protected`がない」と言っているのか？

## privateアクセス修飾子がない

> 実際、 Python では、データ隠蔽を補強するための機構はなにもありません — データの隠蔽はすべて規約に基づいています。 (逆に、C 言語で書かれた Python の実装では実装の詳細を完全に隠蔽し、必要に応じてオブジェクトへのアクセスを制御できます。この機構は C 言語で書かれた Python 拡張で使うことができます。)

「カプセル化できない」ことを意味している。それをクラスと呼べるのか。オブジェクト指向と呼べるのか。

## カプセル化できない

> クライアントはデータ属性を注意深く扱うべきです — クライアントは、メソッドが維持しているデータ属性の不変式を踏みにじり、台無しにするかもしれません。クライアントは、名前の衝突が回避されている限り、メソッドの有効性に影響を及ぼすことなくインスタンスに独自の属性を追加することができる、ということに注意してください — ここでも、名前付けの規約は頭痛の種を無くしてくれます。

解読が必要な文章。仮にクライアントを`self`と読み替える。「データ属性の不変式を踏みにじり、台無しにする」とは具体的にどういうことか？コードで問題を表現して欲しいのだが。

「名前の衝突が回避されている場合は、インスタンスに独自の属性を追加できる」とはどういう意味か？上記の問題を解決する手段の提案として読める。

この文章までで「Pythonにはpublicしかない」ということが明らかになった。アクセス修飾子は`private`も`protected`も存在せず、すべてが`public`である。ゆえに名前重複が発生しやすい。仮に`private`にしようとしても、せいぜい命名規則で「privateのつもり」にするだけで、アクセス自体はできてしまう。

つまり「カプセル化できない」ことを「メソッドが維持しているデータ属性の不変式を踏みにじり、台無しにする」とか「頭痛の種」と言っているのかもしれない。そして、それをPythonで回避するには名付け規約により「privateのつもり」にすることでしか回避できないと言っているのだろう。これが「注意点」だと。

### 命名規則では解決できない

[最初に言った通り](#名前の重複)、名付け規約ではバグ回避できる保証がない。「Pythonはカプセル化できない」という表現を回避し「名前付けの規約は頭痛の種を無くしてくれます」という、あたかも解決方法があるかのように表現しているだけ。実際は「Pythonはカプセル化できない」という一言に尽きる。Pythonで最も隠蔽できる方法は、`self.__変数名`という命名規則に従うことだが、それも`インスタンス名._クラス名__変数名`とすれば参照できてしまう。

Python言語はカプセル化できない。注意してもヒューマンエラーによりバグが生じうる。カプセル化が必要な規模になると、Python言語でなく他の言語で書くのが賢明だと思う。

## selfは省略できない

> メソッドの中から、データ属性を (または別のメソッドも！) 参照するための短縮された記法はありません。私は、この仕様がメソッドの可読性を高めていると感じています。あるメソッドを眺めているときにローカルな変数とインスタンス変数をはっきり区別できるからです。

`self`のことを言っているのだろう。Javaでいう`this`のようなもの。たしかJavaやC#なら名前が重複していないときは省略できたはず。将来の重複に備えたり、明示したいときに`this`を書く。しかしPythonでは選択の余地はなく省略できない。必ず`self.`を必要とする。

しかしPythonの場合、省略するとローカル変数との見分けがつかなくなる。変数の宣言がなく、代入文しかないのが原因である。これはスクリプトなど単純な構造で短いコードをパパっと書くときには有効である。しかし、classのように複雑な構造を書くときには見分けがつかなくなるという弊害が生じる。そこで見分けをつけるために`self`を省略できなくしたのだろう。短く書けるのがPythonの魅力だが、classという皮が増えたせいで、短く書くことすらできなくなった。Pythonのクラスは、Python言語の優位性すら失わさせる。

Pythonではクラスを必要としない小さい規模のコードを書くだけに留めたほうが良いのだろう。学習コスト、バグによるテストや修正コストを最小化するためには。

## selfは予約語ではない

> よく、メソッドの最初の引数を self と呼びます。この名前付けは単なる慣習でしかありません。 self という名前は、 Python では何ら特殊な意味を持ちません。とはいえ、この慣行に従わないと、コードは他の Python プログラマにとってやや読みにくいものとなります。また、 クラスブラウザ (class browser) プログラムがこの慣行をあてにして書かれているかもしれません。

これまでselfがインスタンス変数やインスタンスメソッドの参照に必要であることがわかった。にもかかわらず、`self`は予約語ではない。あくまで習慣にすぎない。その事自体、言語仕様として洗練されていないようにも思えてしまう。

たしか第一引数をself(インスタンスオブジェクト)として扱うはず。それ自体もわかりづらい。さらに、インスタンスメソッドすべてに第一引数`self`が必要なため、書き忘れることが頻発する。面倒くさい。後付けによる弊害の一つではないかと思える。

クラスブラウザ (class browser) プログラムとは何か？謎。

## メソッドの定義箇所はグローバルでもOK

> クラス属性である関数オブジェクトはいずれも、そのクラスのインスタンスのためのメソッドを定義しています。関数定義は、テキスト上でクラス定義の中に入っている必要はありません。関数オブジェクトをクラスのローカルな変数の中に代入するのも OK です。例えば以下のコードのようにします:

```python
def intro(self):
    print('私の名前は', self.name, 'です。')

class Human:
    def __init__(self, name):
        self.name = name
    intro = intro

taro = Human('太郎')
ichiro = Human('一郎')
taro.intro()
ichiro.intro()
```
```sh
$ python3 0.py 
私の名前は 太郎 です。
私の名前は 一郎 です。
```

なんと、クラスの外側にある関数もインスタンスメソッドにできてしまう。単なる関数オブジェクト(関数ポインタ)に過ぎないから、代入式でクラス変数として持たせてしまえば同じことなのだろう。JavaScriptに似ている。

#### 混乱の元

「クラス属性である関数オブジェクト」という表現がパッ見わかりにくい。「クラスが所有する属性のうちの関数オブジェクト」という意味か。つまり「メソッド」。しかしこの文脈では「関数オブジェクト（関数ポインタ）」であることを強調したかったのだろう。そこまでしたのに、さらに以下に続くため、ただただ「わかりにくい」。

> これを実践しても、大抵は単にプログラムの読者に混乱をもたらすだけなので注意してください。

たしかPythonはインデントとかの絡みで「記法を1つに統一することで読みやすくする」みたいなことを長所として主張していなかったか？だから「Pythonは読みやすい」と結論づけていなかったか？classの章に入ってからPythonの長所が崩壊していくばかりに思える。

注意すべきことだと言っているが、元々関数オブジェクトを代入できる言語仕様なのでPythonではクラス定義ができないのだろう。クラスもオブジェクトであり、オブジェクトは自由に操作できてしまうのだから。定義がしたければPythonではなく別の言語にすべきなのだろう。

### selfでメソッドを呼び出せる

> メソッドは、 self 引数のメソッド属性を使って、他のメソッドを呼び出すことができます

```python
class Human:
    def __init__(self, _first_name, _last_name):
        self.first_name = _first_name
        self.last_name = _last_name
    def intro(self):
        print(self.get_serif())
    def get_serif(self):
        return 'My name is ' + self.first_name + ' ' + self.last_name + ' .'

taro = Human('太郎', '山田')
ichiro = Human('一郎', '鈴木')
taro.intro()
ichiro.intro()
```
```sh
$ python3 1.py 
My name is 太郎 山田 .
My name is 一郎 鈴木 .
```

