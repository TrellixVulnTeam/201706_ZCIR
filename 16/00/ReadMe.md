# [9.2. Python のスコープと名前空間](https://docs.python.jp/3/tutorial/classes.html#python-scopes-and-namespaces)

< [9. クラス](https://docs.python.jp/3/tutorial/classes.html#classes) < [Python チュートリアル](https://docs.python.jp/3/tutorial/index.html) < [ドキュメント](https://docs.python.jp/3/index.html)

またしても長文かつコードなし。自分で調べ予想するしかないパターン。ハードなチュートリアル。

## 不穏な前置き

> クラスを紹介する前に、Python のスコープのルールについてあることを話しておかなければなりません。クラス定義は巧みなトリックを名前空間に施すので、何が起こっているのかを完全に理解するには、スコープと名前空間がどのように動作するかを理解する必要があります。ちなみに、この問題に関する知識は全ての Python プログラマにとって有用です。

邪推すると、「この長文で構成された章くらいは理解できないと、何がどうなっているのかさっぱり分からず、事実上クラスを利用することができない」というところか。すでに[前回](https://github.com/pylangstudy/201706/blob/master/15/00/ReadMe.md)、不明点多数で理解できていないのだが……。9章で一気に置いてけぼりを食らった。せめてコードを書いて説明して欲しい。

## 定義

> まず定義から始めましょう。

### 名前空間

> 名前空間 (namespace) とは、名前からオブジェクトへの対応付け (mapping) です。ほとんどの名前空間は、現状では Python の辞書として実装されていますが、そのことは通常は (パフォーマンス以外では) 目立つことはないし、将来は変更されるかもしれません。

だから詳しく知らなくても問題ないということか？

> 名前空間の例には、組込み名の集合 (abs() 等の関数や組込み例外名)、モジュール内のグローバルな名前、関数を呼び出したときのローカルな名前があります。

なぜ関数名が名前空間になる？「モジュール内のグローバルな名前」が名前空間なのか？それは名前空間でなく名前ではないのか？モジュール名が名前空間なのでは？モジュール内にある関数が名前なのでは？

> オブジェクトの属性からなる集合もまた、ある意味では名前空間です。

「ある意味」というのが気になるが、「名前空間」とは`a.key`や`a['key']`, ``などで参照できる子要素を持った親要素のことを言うのか？

> 名前空間について知っておくべき重要なことは、異なった名前空間にある名前の間には全く関係がないということです。例えば、二つの別々のモジュールの両方で関数 maximize という関数を定義することができ、定義自体は混同されることはありません — モジュールのユーザは名前の前にモジュール名をつけなければなりません。

そうして名前重複を回避するのが名前空間だと認識している。

## 属性

> ところで、 属性 という言葉は、ドットに続く名前すべてに対して使っています — 例えば式 z.real で、 real はオブジェクト z の属性です。

`AttributeError`というのをよく目にする。未定義エラーで、その属性は存在しないと怒られる。

> 厳密にいえば、モジュール内の名前に対する参照は属性の参照です。式 modname.funcname では、 modname はあるモジュールオブジェクトで、 funcname はその属性です。この場合には、モジュールの属性とモジュールの中で定義されているグローバル名の間には、直接的な対応付けがされます。これらの名前は同じ名前空間を共有しているのです！ [1]

「モジュールの属性」と「モジュールの中で定義されているグローバル名」は別物なのか？`modname.funcname`で参照しているのはどちら？表現する言葉を言い換えただけでなく、Python内では別物として存在しているのか？さもないと「直接的な対応付けがされます。これらの名前は同じ名前空間を共有しているのです！」と言わないはず。それとも「共有」しているのだからPythonユーザ的には同一とみなしていいという意味か？ならばなぜ、別物であるかのような表現をわざわざした？

> [1]	例外が一つあります。モジュールオブジェクトには、秘密の読取り専用の属性 __dict__ があり、モジュールの名前空間を実装するために使われている辞書を返します; __dict__ という名前は属性ですが、グローバルな名前ではありません。この属性を利用すると名前空間の実装に対する抽象化を侵すことになるので、プログラムを検死するデバッガのような用途に限るべきです。

### globalとlocalの違いをふりかえる

「[1] ... 属性ですが、グローバルな名前ではありません」という一文から察すると、非グローバル(先頭に`__`がついた)変数は、「直接的な対応付け」がされて「いない」ということか。言い方を変えると、localやprivateのように外部参照不可な名前もある。

* ここでいうグローバルとは、publicのことだったのか？
    * classならpublic/privateというが、moduleならglobal/localと呼ぶということか?

module|class|外部から参照|名前の書式
------|-----|-----------|---------
`global`|`public`|○|名前の先頭に`__`を付与しない
`local|`private`|✗|名前の先頭に`__`を付与する

### 「直接的な対応付け」の意味を予想する

local(private)な名前は外部から参照できない。[1]で`__dict__`は例外と言っていることから「local(private)な名前は同じ名前空間を共有していない」ということかもしれない。「スコープがlocalの場合、モジュールの属性とモジュールの中で定義されているローカル名の間には、直接的な対応付けがされない」とも言い換えられる。

ふと気づいたのだが、classでprivate変数を作るときは`self.__変数名`となる。しかし、参照するときは`instance._クラス名__変数名`という名前になる。つまり「privateな名前は直接的な対応付けがされず、`_クラス名__変数名`という名前に置き換えられる」ということになる。このように勝手に名前を変えられてしまうことがないことを「グローバル(public)な名前は直接的な対応付けがされます」と表現していたのかもしれない。だとしたら、あまりにもわかりにくすぎるが。

## 寿命

> 名前空間は様々な時点で作成され、その寿命も様々です。組み込みの名前が入った名前空間は Python インタプリタが起動するときに作成され、決して削除されることはありません。モジュールのグローバルな名前空間は、モジュール定義が読み込まれたときに作成されます。通常、モジュールの名前空間は、インタプリタが終了するまで残ります。インタプリタのトップレベルで実行された文は、スクリプトファイルから読み出されたものでも対話的に読み出されたものでも、 __main__ という名前のモジュールの一部分であるとみなされるので、独自の名前空間を持つことになります。 (組み込みの名前は実際にはモジュール内に存在します。そのモジュールは builtins と呼ばれています。)

クラスの章であるにもかかわらず、クラスに関する寿命が書かれていない。おそらくインスタンス変数の寿命だろうが。

## 関数のローカルな名前空間

> 関数のローカルな名前空間は、関数が呼び出されたときに作成され、関数から戻ったときや、関数内で例外が送出され、かつ関数内で処理されなかった場合に削除されます。 (実際には、忘れられる、と言ったほうが起きていることをよく表しています。) もちろん、再帰呼出しのときには、各々の呼び出しで各自のローカルな名前空間があります。

翻訳のせいか「忘れられる」だの「起きている」だの意味不明。ようするに「関数内から脱出したら関数内名前空間は削除される」ということだろう。

## スコープ

> スコープ (scope) とは、ある名前空間が直接アクセスできるような、 Python プログラムのテキスト上の領域です。 “直接アクセス可能” とは、修飾なしに (訳注: spam.egg ではなく単に egg のように) 名前を参照した際に、その名前空間から名前を見つけようと試みることを意味します。

C言語やほかのプログラミング言語とは「スコープ」という言葉の意味が違うように思う。アクセス可能領域のことだと思ったが、Pythonではそのうち、「修飾子なしに」という条件が加わっているようだ。

### 3つのスコープ

> スコープは静的に決定されますが、動的に使用されます。実行中はいつでも、直接名前空間にアクセス可能な、少なくとも三つの入れ子になったスコープがあります:

* 最初に探される、最も内側のスコープは、ローカルな名前を持っています。
* 外側の(enclosing)関数のスコープは、近いほうから順に探され、ローカルでもグローバルでもない名前を持っています。
* 次のスコープは、現在のモジュールのグローバルな名前を持っています。
* 一番外側の(最後に検索される)スコープはビルトイン名を持っています。

3つでなく4つに見える。「次のスコープは、」というのが紛らわしい。

スコープ|説明
--------|----
ローカル|最も内側
グローバル(ビルトイン名)|一番外側
ローカルでもグローバルでもない|外側の(enclosing)関数のスコープ

* 「ローカルでもグローバルでもない」が謎
    * モジュール関数内のスコープを言っているのか？
        * モジュール関数内のスコープはローカルではないのか？
* クラスは？クラスの章なのにクラスの説明がないのですが……。
    * 「直接名前空間にアクセス可能」ではないから対象外ということか？

おそらく最上位、最下位、中間、くらいの意味しかないのだろう。

### global

> 名前が global と宣言されている場合、その名前に対する参照や代入は全て、モジュールのグローバルな名前の入った中間のスコープに対して直接行われます。最内スコープの外側にある変数に再束縛するには、 nonlocal 文が使えます。nonlocal と宣言されなかった変数は、全て読み出し専用となります (そのような変数に対する書き込みは、単に 新しい ローカル変数をもっとも内側のスコープで作成し、外部のスコープの値は変化しません)。

意味不明。コードで書いてくれ。適当に`global`と変数名の前につけて試してみた。

```python
global global_var
#global global_var = 'global_var' # SyntaxError: invalid syntax 代入できないらしい
#print(global_var) # NameError: name 'global_var' is not defined なぜか参照できない
```

宣言はできているように見える。しかし参照できないから確かめようがない。ググった。

http://uxmilk.jp/12505

#### コード書いて確かめる

##### グローバル変数を宣言する

* `global`キーワードを使わずに宣言する
* モジュール配下に直接書く

```python
global_var = 'global_var'
def func():
    print(global_var)

func()
```
```sh
$ python 1.py 
global_var
```

##### グローバル変数と同一名のローカル変数を宣言する

```python
global_var = 'global_var'
def func():
    global_var = 'global_var_local_use'
    print(global_var)

func()
```
```sh
$ python 2.py 
global_var_local_use
```

グローバル変数と同一のローカル変数があると、グローバル変数が参照できない。ローカル変数への参照となる。これをグローバル側に指定するのが`global`キーワードである。

##### グローバル変数と同一名のローカル変数がある中でグローバル変数に代入する

```python
global_var = 'global_var'
def func():
    global global_var
    global_var = 'global_var_local_use'
    print(global_var)
    
func()
```
```sh
$ python 3.py 
global_var
```

* `global グローバル変数と同一名`と宣言すると、その名前でグローバル変数に代入できる
* 代入式は別に書くこと
* 関数の先頭で宣言すること

###### 代入式は別に書くこと

```python
global_var = 'global_var'
def func():
    global global_var = 'global_var_local_use'
    print(global_var)
```
```sh
$ python 4.py 
  File "4.py", line 3
    global global_var = 'global_var_local_use'
                      ^
SyntaxError: invalid syntax
```

###### 関数の先頭で宣言すること

```python
global_var = 'global_var'
def func():
    print(global_var)
    global global_var
    
func()
```
```sh
$ python 5.py 
  File "5.py", line 4
    global global_var
    ^
SyntaxError: name 'global_var' is used prior to global declaration
```

## nonlocal

> 最内スコープの外側にある変数に再束縛するには、 [nonlocal](https://docs.python.jp/3/reference/simple_stmts.html#nonlocal) 文が使えます。nonlocal と宣言されなかった変数は、全て読み出し専用となります (そのような変数に対する書き込みは、単に 新しい ローカル変数をもっとも内側のスコープで作成し、外部のスコープの値は変化しません)。

```python
global_var = 'global_var'
def func():
#    nonlocal global_var # SyntaxError: no binding for nonlocal 'global_var' found
    global_var = 'global_var_local_use'
#    nonlocal global_var # SyntaxError: name 'global_var' is assigned to before nonlocal declaration
    print(global_var)
#    nonlocal global_var # SyntaxError: name 'global_var' is used prior to nonlocal declaration
    print(global_var)
    
func()
```
```sh
$ python 6.py 
global_var_local_use
global_var_local_use
```

[nonlocal](https://docs.python.jp/3/reference/simple_stmts.html#nonlocal)には以下のようにある。

> nonlocal 文は、列挙された識別子がグローバルを除く一つ外側のスコープで先に束縛された変数を参照するようにします。

> この文は、中にあるコードが、グローバル (モジュール) スコープ以外のローカルスコープの外側の変数を再束縛できるようにします。

モジュール内グローバル変数である`global_var`に適用できないということだろう。

### 中間スコープを作ってみる

```python
module_var = 'global_var'
def func():
    func_var = 'func_var'
    def inner_func():
        print(func_var)
    inner_func()
    
func()
```
```sh
$ python 7.py 
func_var
```

### 中間とローカルで同一名の変数を作る

```python
module_var = 'global_var'
def func():
    func_var = 'func_var'
    def inner_func():
        func_var = 'func_var_inner'
        print(func_var)
    inner_func()
    print(func_var)
    
func()
```
```sh
$ python 8.py 
func_var_inner
func_var
```

中間でなくローカルのほうを参照する。

### ローカル内で1つ上にある中間スコープの同一名変数に代入する

```python
module_var = 'global_var'
def func():
    func_var = 'func_var'
    def inner_func():
        nonlocal func_var
        func_var = 'func_var_inner'
        print(func_var)
    inner_func()
    print(func_var)

func()
```
```sh
$ python 9.py 
func_var_inner
func_var_inner
```

## 参照

> 通常、ローカルスコープは (プログラムテキスト上の) 現在の関数のローカルな名前を参照します。

コードで確認した通り。

> 関数の外側では、ローカルスコープはグローバルな名前空間と同じ名前空間、モジュールの名前空間を参照します。

意味不明。まさか、関数の外側から関数内のローカル変数を参照できるわけではないはず。以下で確かめた限りでは不可能。

```python
module_var = 'global_var'
def func():
    func_var = 'func_var'

#print(func().func_var) # AttributeError: 'NoneType' object has no attribute 'func_var'
#print(func.func_var) # AttributeError: 'function' object has no attribute 'func_var'
```

> クラス定義では、ローカルスコープの中にもう一つ名前空間が置かれます。

そうですか。で？

## スコープはテキスト上で決定されている

> スコープはテキスト上で決定されていると理解することが重要です。モジュール内で定義される関数のグローバルなスコープは、関数がどこから呼び出されても、どんな別名をつけて呼び出されても、そのモジュールの名前空間になります。反対に、実際の名前の検索は実行時に動的に行われます — とはいえ、言語の定義は、”コンパイル” 時の静的な名前解決の方向に進化しているので、動的な名前解決に頼ってはいけません！ (事実、ローカルな変数は既に静的に決定されています。)

動的な名前解決とは何かがわからないので話が見えない。

## ローカルになる

> Python 特有の癖として、代入を行うと – どの global 文も有効でない場合は – 名前がいつも最も内側のスコープに入るというものがあります。代入はデータのコピーを行いません — 単に名前をオブジェクトに結びつける (bind) だけです。オブジェクトの削除でも同じです: del x は、 x をローカルスコープが参照している名前空間から削除します。実際、新たな名前を導入する操作は全てローカルスコープを用います。とりわけ、 import 文や関数定義は、モジュールや関数の名前をローカルスコープに結び付けます。

### 代入はデータのコピーを行いません

データ(値)の先頭アドレスをコピーするということだろう。

スコープの話なのに、ドサクサに紛れて代入操作についての説明を混入させてきたのが謎。Python 特有の癖は知らないが、この文書の癖が強い。

### Python 特有の癖？

#### 名前が内側スコープに入る

自然だと思うが、他の言語では違ったか？

* 名前重複を回避しやすくする
* メモリ寿命を短くする

#### 削除

> del x は、 x をローカルスコープが参照している名前空間から削除します。

#### とにかくローカルに持たせる

> 新たな名前を導入する操作は全てローカルスコープを用います。とりわけ、 import 文や関数定義は、モジュールや関数の名前をローカルスコープに結び付けます。

importした箇所の分だけローカルスコープとしてメモリ確保される、と言っているのか？

## global文

[global](https://docs.python.jp/3/reference/simple_stmts.html#global) 文を使うと、特定の変数がグローバルスコープに存在し、そこで再束縛されることを指示できます。 [nonlocal](https://docs.python.jp/3/reference/simple_stmts.html#nonlocal) 文は、特定の変数が外側のスコープに存在し、そこで再束縛されることを指示します。

まさか最後になってからglobal文の説明をしてくるとは思わなかった。明らかに順序がおかしい。説明文もおかしい。「再束縛」というキーワードを用いているが、その用語についての説明が一度もなかった。

「global文はローカルスコープ内からグローバルスコープ変数にアクセスするときに使います」のような説明が自然ではないか？その後で名前が同一のときなど、細かい説明をすればいい。

## まとめ

* 名前空間とは、`a.key`, `a['key']`のように名前の入れ子にできる要素のことである
    * おそらくパッケージ、モジュール、クラス、dict, list, tupleのようなもののこと
* スコープとは名前を参照できる範囲のことである
    * 異なるスコープで同一名の場合、ローカルスコープ側が参照される
        * グローバルスコープ側は参照できない。しかし、以下の文を使うことで可能である
            * ローカルからグローバル側の名前を参照する
                * `[global](https://docs.python.jp/3/reference/simple_stmts.html#global) 変数名`
            * ローカルからグローバルより下の名前を参照する
                * `[nonlocal](https://docs.python.jp/3/reference/simple_stmts.html#nonlocal) 変数名`

## 所感

Python文書のわかりづらさが目立った。まともに読めない。日本語でまともに説明できていないのに、コードを1つも書いていないのが最悪。

