# [9.3.4. メソッドオブジェクト](https://docs.python.jp/3/tutorial/classes.html#method-objects)

< [9.3. クラス初見](https://docs.python.jp/3/tutorial/classes.html#a-first-look-at-classes) < [9. クラス](https://docs.python.jp/3/tutorial/classes.html#classes) < [Python チュートリアル](https://docs.python.jp/3/tutorial/index.html) < [ドキュメント](https://docs.python.jp/3/index.html)

## メソッドオブジェクト

### 呼出

> 普通、メソッドはバインドされた直後に呼び出されます

`x.f()`のように。

### オブジェクト

> 必ずしもメソッドをその場で呼び出さなければならないわけではありません。 x.f はメソッドオブジェクトであり、どこかに記憶しておいて後で呼び出すことができます。

```python
class MyClass:
    def __init__(self):
        self.var = 'var'
    def method(self):
        print('method')
    
x = MyClass()
x.method()

m = x.method
m()
```
```sh
$ python3 0.py 
method
method
```

MyClassのインスタンスメソッド`method`を、変数`m`に代入した。変数`m`には先述のメソッドオブジェクトが入っている。

### self

> メソッドが呼び出されるときには実際には何が起きているのでしょうか？

> f() の関数定義では引数を一つ指定していたにもかかわらず、上の例では x.f() が引数なしで呼び出されています。引数はどうなったのでしょうか？たしか、引数が必要な関数を引数無しで呼び出すと、 Python が例外を送出するはずです — たとえその引数が実際には使われなくても…。

> もう答は想像できているかもしれませんね: メソッドについて特別なこととして、インスタンスオブジェクトが関数の第1引数として渡されます。 例では、 x.f() という呼び出しは、 MyClass.f(x) と厳密に等価なものです。 一般に、 n 個の引数リストもったメソッドの呼出しは、そのメソッドのインスタンスオブジェクトを最初の引数の前に挿入した引数リストで、メソッドに対応する関数を呼び出すことと等価です。

想像できるわけがない。「MyClass.f(x) と厳密に等価」「引数リストで渡しても同様」であることを以下コードで確認してみた。

```python
class MyClass:
    def __init__(self, var):
        self.var = var
    def method(self):
        print('var =', self.var)
    
a = MyClass('a')
b = MyClass('b')
a.method()
b.method()
MyClass.method(a)
MyClass.method(b)
MyClass.method(*[a])
# TypeError: method() takes 1 positional argument but 2 were given
#a.method(a)
#b.method(b)
#a.method(b)
#b.method(a)
```
```sh
$ python3 1.py 
var = a
var = b
var = a
var = b
var = a
```

### 実装

> もしまだメソッドの動作を理解できなければ、一度実装を見てみると事情がよく分かるかもしれません。データ属性ではないインスタンス属性が参照された時は、そのクラスが検索されます。その名前が有効なクラス属性を表している関数オブジェクトなら、インスタンスオブジェクトと見つかった関数オブジェクト (へのポインタ) を抽象オブジェクト、すなわちメソッドオブジェクトにパックして作成します。メソッドオブジェクトが引数リストと共に呼び出されるとき、インスタンスオブジェクトと渡された引数リストから新しい引数リストを作成して、元の関数オブジェクトを新しい引数リストで呼び出します。

理解できるわけがない。実装コードはどこにあるのか。ググってみた。

* https://github.com/python/cpython
* https://github.com/python/cpython/blob/master/Objects/methodobject.c

C言語について勉強せねばならない。周辺のPython実装について理解せねばならない。チュートリアルの範疇を超える。これを読まねばメソッド動作の理解ができないのなら、一生できる気がしない。

知りたいのはそんなことではない。

## 蛇足

### なぜselfが必要なのか？

面倒！と誰もが思うはず。ググってみた。

* https://teratail.com/questions/10814

最初の解答が素敵。乱暴に書くと、スクリプト言語なのだからサクっと動くコードさえかければいい。selfについての疑問は捨てろと。Pythonを書き始めて間もないが、大規模なコードを書くのは厳しいと感じる。静的型付けができないことによるバグ発生やテスト負荷が高まるから。クラスもカプセル化できないという根本的で致命的な欠点がある。短いスクリプト言語としては便利だろうから、「Pythonとは短いスクリプトを書く言語」という認識のほうがいい。オブジェクト指向は後付けらしいから、無理があるのだろう。Python文書ではオブジェクト指向であることを高らかに謳っているから、まんまと騙されるのである。

* http://coreblog.org/ats/translation-of-why-explicit-self-has-to-stay/

よくわからないながらも上記を読んでみた。やはり「Pythonはそういう言語。それを理解して使うべき。嫌なら別の言語を使うべき」という結論になりそう。

クラスの章なのに、Pythonにおけるクラスやオブジェクト指向が如何に残念でお粗末なのかが見えてくるように思う。どうしてもJavaなどのオブジェクト指向と比べて見劣りする。動的言語の性質や使いどころが理解できていないからかもしれないが。

* Pythonがカプセル化できないせいで他のオブジェクト指向と比べて機能を満たしていないように見える
* インスタンスメソッドにいちいち第一引数`self`が必要である

べつに悪い点だけではないはずが、他の言語と使い分けることを考えたほうがいいのではないかと思う。

### Pythonの使いどころ

Pythonが適しているのは小規模なコードだと思う。

大規模にするなら静的型付けによるエラーチェックや、オブジェクト指向によりDRYに書くことでバグ作り込み機会を減らしたい。しかし、Pythonは静的型付けできない。`del クラスメンバ`のようにするとクラス定義から削除できてしまえる等。オブジェクト指向もできない（カプセル化できない、`protected`のアクセ集修飾子がない等）。少なくともJava, C#などの言語でいうような「オブジェクト指向」には到底及ばない。そもそも動的に書き換えられる言語仕様なので実行時エラーが多くなりがち。よって、大規模なコードを書くのには向いていない。せいぜいスクリプト的な使い方が関の山である。ポジティブに言い換えれば、Pythonは短いコードを素早く書ける言語である。

#### クラスは難しいわりに得られるものが少ない？

クラスは一気に難しくなる。もともとオブジェクト指向でない言語を、オブジェクト指向的にするよう追加したため、わかりづらいことになっている。それなら素直にJava, C#などのオブジェクト指向言語を学んだほうが理解しやすい。

PythonやJavaScriptは静的型付けしない独特な仕組みがあるため難しい。

とくにカプセル化できず、protectedもないため責任の分離ができない点が大きい。privateにしても、_Class__memberとすればアクセスできてしまう。どこでどのように書き換えられたか判然としない。結果的に、全コードを読み返さねばならない。それの一体どこがオブジェクト指向なのか。クラスを使う意味や価値はあるのか？モジュールと大差ないのでは？

#### Pythonはスクリプト言語である

ソフトウェアは複雑化の一途をたどっている。PythonはJavaなどのオブジェクト指向よりも、複雑な構造を書くのが難しい。カプセル化もできないから複雑なソフトウェアを書くのに向いていない。はたしてPython言語は使うに値するのか？

Pythonはスクリプトのように短いコードを書く分には使えると思う。するとクラスの必要性が薄まる。また、クラスが後付感満載により無用な難しさを伴う。いっそクラスを学ばないほうが良いかもしれない。モジュールと関数だけで実装できる規模にとどめてPythonを使ったほうがいいのではないか。

Pythonの存在意義を擁護しようとすると、クラスの存在意義が薄まる。クラスの存在意義を主張すると、Pythonの存在意義が薄まる。つまり、Pythonはクラスが不要な小規模コードを書くのに向いている。大規模コードになるなら、Javaなどのオブジェクト指向言語で書いたほうが良い。

